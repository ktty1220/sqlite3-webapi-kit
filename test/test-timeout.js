// Generated by CoffeeScript 1.12.6
var assert, coverage, dbname, e, fs, randtime, sqlited, vows;

vows = require('vows');

assert = require('assert');

fs = require('fs');

try {
  coverage = require('coverage');
} catch (error) {
  e = error;
  coverage = {
    require: require
  };
}

try {
  sqlited = coverage.require(__dirname + "/../lib/sqlite3-webapi-kit");
} catch (error) {
  e = error;
  sqlited = coverage.require("../lib/sqlite3-webapi-kit");
}

dbname = 'test.db3';

randtime = [90, 30, 70, 10, 20, 100, 80, 60, 40, 50];

vows.describe('core test').addBatch({
  'メモリ上のDBをオープン (200ミリ秒後にクローズ)': {
    topic: function() {
      sqlited.open((function(_this) {
        return function(err) {
          setTimeout(function() {
            sqlited.close();
          }, 200);
          return _this.callback(err, sqlited.dbname());
        };
      })(this));
    },
    'DBオブジェクトのfilenameが「:memory:」になっている': (function(_this) {
      return function(topic) {
        return assert.equal(topic, ':memory:');
      };
    })(this)
  }
}).addBatch({
  '2重オープン (待機指定なし)': {
    topic: function() {
      var start;
      start = Date.now();
      sqlited.open(dbname, (function(_this) {
        return function(err) {
          return _this.callback(null, {
            err: err,
            elapsed: Date.now() - start
          });
        };
      })(this));
    },
    '1007エラーが発生する': (function(_this) {
      return function(topic) {
        return assert.equal(topic.err.errno, 1007);
      };
    })(this),
    '即座にコールバックされている': (function(_this) {
      return function(topic) {
        return assert.isTrue(topic.elapsed <= 10);
      };
    })(this)
  }
}).addBatch({
  '2重オープン (0ミリ秒待機)': {
    topic: function() {
      var start;
      start = Date.now();
      sqlited.open(dbname, null, 0, (function(_this) {
        return function(err) {
          return _this.callback(null, {
            err: err,
            elapsed: Date.now() - start
          });
        };
      })(this));
    },
    '1007エラーが発生する': (function(_this) {
      return function(topic) {
        return assert.equal(topic.err.errno, 1007);
      };
    })(this),
    '即座にコールバックされている': (function(_this) {
      return function(topic) {
        return assert.isTrue(topic.elapsed <= 10);
      };
    })(this)
  }
}).addBatch({
  '2重オープン (100ミリ秒待機)': {
    topic: function() {
      var start;
      start = Date.now();
      sqlited.open(dbname, null, 100, (function(_this) {
        return function(err) {
          return _this.callback(null, {
            err: err,
            elapsed: Date.now() - start
          });
        };
      })(this));
    },
    '1007エラーが発生する': (function(_this) {
      return function(topic) {
        return assert.equal(topic.err.errno, 1007);
      };
    })(this),
    '100ミリ秒後にコールバックされている': (function(_this) {
      return function(topic) {
        return assert.isTrue(100 <= topic.elapsed && topic.elapsed <= 110);
      };
    })(this)
  }
}).addBatch({
  '2重オープン (+100ミリ秒待機)': {
    topic: function() {
      sqlited.open(dbname, null, 100, (function(_this) {
        return function(err) {
          return _this.callback(null, err);
        };
      })(this));
    },
    'エラーが発生しない': (function(_this) {
      return function(topic) {
        return assert.isUndefined(topic);
      };
    })(this)
  }
}).addBatch({
  'クローズ直後にオープン': {
    topic: function() {
      sqlited.close((function(_this) {
        return function() {
          sqlited.open(dbname, function(err) {
            return _this.callback(null, err);
          });
        };
      })(this));
    },
    'エラーが発生しない': (function(_this) {
      return function(topic) {
        return assert.isUndefined(topic);
      };
    })(this)
  }
}).addBatch({
  '複数オープン (すべてタイムアウトする場合)': {
    topic: function() {
      var j, len, open, quelen1, quelen2, timeout, timeouted;
      timeouted = [];
      quelen1 = [];
      quelen2 = [];
      open = (function(_this) {
        return function(timeout) {
          sqlited.open(dbname, null, timeout, function(err) {
            if (err.errno === 1007) {
              timeouted.push(timeout);
            }
            quelen2.push(sqlited.variables._openQueue.length);
            if (timeout === Math.max.apply(null, randtime)) {
              return _this.callback(null, {
                timeouted: timeouted,
                quelen1: quelen1,
                quelen2: quelen2
              });
            }
          });
          quelen1.push(sqlited.variables._openQueue.length);
        };
      })(this);
      for (j = 0, len = randtime.length; j < len; j++) {
        timeout = randtime[j];
        open(timeout);
      }
    },
    '待機時間が短い順に1007エラーが発生する': (function(_this) {
      return function(topic) {
        var i, j, ref, results, sorted;
        sorted = randtime.sort(function(a, b) {
          return a - b;
        });
        results = [];
        for (i = j = 0, ref = sorted.length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          results.push(assert.equal(topic.timeouted[i], sorted[i]));
        }
        return results;
      };
    })(this),
    '待ち行列に追加されていく': (function(_this) {
      return function(topic) {
        var i, j, results;
        results = [];
        for (i = j = 0; j <= 9; i = ++j) {
          results.push(assert.equal(topic.quelen1[i], i + 1));
        }
        return results;
      };
    })(this),
    '待ち行列から除去されていく': (function(_this) {
      return function(topic) {
        var i, j, results;
        results = [];
        for (i = j = 0; j <= 9; i = ++j) {
          results.push(assert.equal(topic.quelen2[i], 9 - i));
        }
        return results;
      };
    })(this)
  }
}).addBatch({
  'クローズ': {
    topic: function() {
      sqlited.close((function(_this) {
        return function(err) {
          return _this.callback(err, {
            db: sqlited.variables._db,
            que: sqlited.variables._openQueue
          });
        };
      })(this));
    },
    '_dbがnullになっている': (function(_this) {
      return function(topic) {
        return assert.isNull(topic.db);
      };
    })(this),
    '待ち行列が空になっている': (function(_this) {
      return function(topic) {
        return assert.lengthOf(topic.que, 0);
      };
    })(this)
  }
}).addBatch({
  '複数オープン (すべてタイムアウトしない場合)': {
    topic: function() {
      var i, j, open, opened, quelen1, quelen2;
      opened = [];
      quelen1 = [];
      quelen2 = [];
      open = (function(_this) {
        return function(index) {
          sqlited.open(dbname, null, 1000, function(err) {
            if (err == null) {
              opened.push(index);
              setTimeout(function() {
                sqlited.close();
                quelen2.push(sqlited.variables._openQueue.length);
                if (index === 9) {
                  return _this.callback(null, {
                    opened: opened,
                    quelen1: quelen1,
                    quelen2: quelen2
                  });
                }
              }, 10);
            }
          });
          quelen1.push(sqlited.variables._openQueue.length);
        };
      })(this);
      for (i = j = 0; j <= 9; i = ++j) {
        open(i);
      }
    },
    '呼び出された順にオープンに成功する': (function(_this) {
      return function(topic) {
        var i, j, results;
        results = [];
        for (i = j = 0; j <= 9; i = ++j) {
          results.push(assert.equal(topic.opened[i], i));
        }
        return results;
      };
    })(this),
    '待ち行列に追加されていく': (function(_this) {
      return function(topic) {
        var i, j, results;
        results = [];
        for (i = j = 0; j <= 9; i = ++j) {
          results.push(assert.equal(topic.quelen1[i], i));
        }
        return results;
      };
    })(this),
    '待ち行列から除去されていく': (function(_this) {
      return function(topic) {
        var i, j, results;
        results = [];
        for (i = j = 0; j <= 9; i = ++j) {
          results.push(assert.equal(topic.quelen2[i], 9 - i));
        }
        return results;
      };
    })(this)
  }
})["export"](module);
